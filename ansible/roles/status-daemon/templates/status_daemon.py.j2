#!/usr/bin/env python3
"""
Status Daemon - Health checks, lease management, idle detection, self-termination.
"""

import os
import time
import math
import threading
import subprocess
import requests
from datetime import datetime, timedelta
from typing import Optional, Tuple
from flask import Flask, jsonify, request, render_template_string

app = Flask(__name__)

# Configuration
LAMBDA_API_KEY = "{{ lambda_api_key }}"
STATUS_TOKEN = "{{ status_token }}"
IDLE_TIMEOUT_MINUTES = {{ idle_timeout_minutes }}
LEASE_HOURS = {{ lease_hours }}
MAX_LEASE_HOURS = {{ max_lease_hours }}

# Metrics-based idle detection configuration
SGLANG_METRICS_URL = "http://localhost:{{ sglang_metrics_port }}{{ sglang_metrics_path }}"
N8N_METRICS_URL = "http://localhost:{{ n8n_port }}{{ n8n_metrics_path }}"
REQUEST_IDLE_TIMEOUT = {{ request_idle_timeout_minutes }} * 60
METRICS_CHECK_INTERVAL = {{ metrics_check_interval_seconds }}
FAILED_CHECK_THRESHOLD = {{ metrics_failed_check_threshold }}

# State
BOOT_TIME = datetime.utcnow()
LAST_ACTIVITY = datetime.utcnow()
SHUTDOWN_AT = BOOT_TIME + timedelta(hours=LEASE_HOURS)
INSTANCE_ID = None

# Metrics-based idle detection state
last_sglang_activity = None
last_n8n_activity = None
sglang_tokens_total = 0
n8n_executions_total = 0
sglang_metrics_healthy = True
n8n_metrics_healthy = True
sglang_failed_checks = 0
n8n_failed_checks = 0


def get_instance_id():
    """Get instance ID from Lambda API by matching IP."""
    global INSTANCE_ID
    if INSTANCE_ID:
        return INSTANCE_ID

    max_retries = 5
    retry_delay = 2

    for attempt in range(max_retries):
        try:
            my_ip = subprocess.check_output(
                ["curl", "-s", "ifconfig.me"], timeout=10
            ).decode().strip()

            if not my_ip:
                app.logger.warning(f"Empty IP response, retry {attempt + 1}/{max_retries}")
                time.sleep(retry_delay)
                continue

            resp = requests.get(
                "https://cloud.lambdalabs.com/api/v1/instances",
                headers={"Authorization": f"Bearer {LAMBDA_API_KEY}"},
                timeout=15
            )
            resp.raise_for_status()

            for instance in resp.json().get("data", []):
                if instance.get("ip") == my_ip:
                    INSTANCE_ID = instance.get("id")
                    app.logger.info(f"Found instance ID: {INSTANCE_ID}")
                    return INSTANCE_ID

            app.logger.warning(f"Instance not found for IP {my_ip}, retry {attempt + 1}/{max_retries}")

        except subprocess.TimeoutExpired:
            app.logger.error(f"IP lookup timeout, retry {attempt + 1}/{max_retries}")
        except requests.exceptions.RequestException as e:
            app.logger.error(f"Lambda API error: {e}, retry {attempt + 1}/{max_retries}")
        except Exception as e:
            app.logger.error(f"Unexpected error getting instance ID: {e}")

        if attempt < max_retries - 1:
            time.sleep(retry_delay * (attempt + 1))

    fallback_id = os.environ.get("HOSTNAME", "unknown")
    app.logger.error(f"Failed to get instance ID after {max_retries} retries, using fallback: {fallback_id}")
    return fallback_id


def get_gpu_utilization():
    """Get GPU utilization from nvidia-smi."""
    try:
        output = subprocess.check_output(
            ["nvidia-smi", "--query-gpu=utilization.gpu", "--format=csv,noheader,nounits"],
            timeout=5
        ).decode().strip()
        return int(output.split("\n")[0])
    except (subprocess.SubprocessError, FileNotFoundError, ValueError):
        return -1


def get_model_loaded():
    """Check which model SGLang is serving."""
    try:
        resp = requests.get("http://localhost:{{ sglang_port }}/v1/models", timeout=5)
        models = resp.json().get("data", [])
        if models:
            return models[0].get("id", "unknown")
    except (requests.exceptions.RequestException, KeyError, ValueError):
        pass
    return "not-loaded"


def parse_prometheus_metrics(text: str, metric_name: str) -> Optional[float]:
    """
    Extract numeric value from Prometheus text format.

    If multiple lines match metric_name (due to different labels),
    returns the FIRST matching value.
    """
    for line in text.split('\n'):
        if line.startswith('#'):
            continue
        if line.startswith(metric_name):
            parts = line.split()
            if len(parts) >= 2:
                try:
                    value = float(parts[-1])
                    if math.isnan(value) or math.isinf(value) or value < 0:
                        app.logger.warning(f"Invalid metric value: {line}")
                        continue
                    return value
                except ValueError:
                    continue
    return None


def check_sglang_activity() -> Tuple[bool, bool]:
    """
    Check SGLang metrics for activity.

    Returns:
        (activity_detected: bool, metrics_healthy: bool)
    """
    global sglang_tokens_total, last_sglang_activity, sglang_failed_checks

    try:
        resp = requests.get(SGLANG_METRICS_URL, timeout=5)
        resp.raise_for_status()
        sglang_failed_checks = 0
        metrics_text = resp.text

        # Check for running requests (gauge)
        num_running = parse_prometheus_metrics(metrics_text, "sglang:num_running_reqs")
        if num_running is not None and num_running > 0:
            app.logger.info(f"SGLang activity: {int(num_running)} running requests")
            last_sglang_activity = datetime.utcnow()
            return True, True

        # Check for token generation (counter delta)
        tokens_total = parse_prometheus_metrics(metrics_text, "sglang:generation_tokens_total")
        if tokens_total is not None:
            if tokens_total < sglang_tokens_total:
                app.logger.warning("SGLang counter reset detected (service restart)")
                last_sglang_activity = datetime.utcnow()
                sglang_tokens_total = tokens_total
                return True, True

            if tokens_total > sglang_tokens_total:
                delta = int(tokens_total - sglang_tokens_total)
                app.logger.info(f"SGLang activity: {delta} tokens generated")
                last_sglang_activity = datetime.utcnow()
                sglang_tokens_total = tokens_total
                return True, True

            sglang_tokens_total = tokens_total

        return False, True

    except requests.exceptions.RequestException as e:
        sglang_failed_checks += 1
        app.logger.warning(f"SGLang metrics check failed ({sglang_failed_checks}/{FAILED_CHECK_THRESHOLD}): {e}")
        if sglang_failed_checks >= FAILED_CHECK_THRESHOLD:
            return False, False
        return False, True


def check_n8n_activity() -> Tuple[bool, bool]:
    """
    Check n8n metrics for activity.

    Returns:
        (activity_detected: bool, metrics_healthy: bool)
    """
    global n8n_executions_total, last_n8n_activity, n8n_failed_checks

    try:
        resp = requests.get(N8N_METRICS_URL, timeout=5)
        resp.raise_for_status()
        n8n_failed_checks = 0
        metrics_text = resp.text

        executions_total = parse_prometheus_metrics(metrics_text, "n8n_workflow_executions_total")
        if executions_total is not None:
            if executions_total < n8n_executions_total:
                app.logger.warning("n8n counter reset detected (service restart)")
                last_n8n_activity = datetime.utcnow()
                n8n_executions_total = executions_total
                return True, True

            if executions_total > n8n_executions_total:
                delta = int(executions_total - n8n_executions_total)
                app.logger.info(f"n8n activity: {delta} workflow executions")
                last_n8n_activity = datetime.utcnow()
                n8n_executions_total = executions_total
                return True, True

            n8n_executions_total = executions_total

        return False, True

    except requests.exceptions.RequestException as e:
        n8n_failed_checks += 1
        app.logger.warning(f"n8n metrics check failed ({n8n_failed_checks}/{FAILED_CHECK_THRESHOLD}): {e}")
        if n8n_failed_checks >= FAILED_CHECK_THRESHOLD:
            return False, False
        return False, True


def check_auth():
    """Verify bearer token."""
    auth = request.headers.get("Authorization", "")
    if auth.startswith("Bearer "):
        return auth[7:] == STATUS_TOKEN
    return False


def terminate_instance(reason: str):
    """Call Lambda API to terminate this instance."""
    instance_id = get_instance_id()
    app.logger.warning(f"TERMINATING INSTANCE: {reason}")

    max_retries = 3
    retry_delay = 5

    for attempt in range(max_retries):
        try:
            resp = requests.post(
                "https://cloud.lambdalabs.com/api/v1/instance-operations/terminate",
                headers={
                    "Authorization": f"Bearer {LAMBDA_API_KEY}",
                    "Content-Type": "application/json"
                },
                json={"instance_ids": [instance_id]},
                timeout=30
            )
            app.logger.info(f"Terminate response: {resp.status_code} - {resp.text}")

            if resp.status_code in (200, 202):
                app.logger.info("Termination successful")
                return

            app.logger.warning(f"Termination returned {resp.status_code}, retry {attempt + 1}/{max_retries}")

        except requests.exceptions.RequestException as e:
            app.logger.error(f"Termination request failed: {e}, retry {attempt + 1}/{max_retries}")
        except Exception as e:
            app.logger.error(f"Unexpected termination error: {e}")

        if attempt < max_retries - 1:
            time.sleep(retry_delay)

    app.logger.error(f"Failed to terminate instance after {max_retries} retries")


def idle_checker():
    """Background thread checking for idle timeout and lease expiry using metrics."""
    global LAST_ACTIVITY, SHUTDOWN_AT, sglang_metrics_healthy, n8n_metrics_healthy

    app.logger.info("Idle checker started (metrics-based detection)")

    while True:
        time.sleep(METRICS_CHECK_INTERVAL)
        now = datetime.utcnow()

        # Check lease expiry
        if now > SHUTDOWN_AT:
            terminate_instance("lease_expired")
            return

        # Poll metrics for activity
        sglang_active, sglang_healthy = check_sglang_activity()
        n8n_active, n8n_healthy = check_n8n_activity()

        # Update health status
        sglang_metrics_healthy = sglang_healthy
        n8n_metrics_healthy = n8n_healthy

        # OR logic: any activity resets timer
        if sglang_active or n8n_active:
            LAST_ACTIVITY = now
            app.logger.debug("Activity detected, idle timer reset")
            continue

        # Check idle timeout (only if we have a last activity timestamp)
        if last_sglang_activity is None and last_n8n_activity is None:
            app.logger.debug("No activity recorded yet, waiting for first request")
            continue

        # Calculate most recent activity
        most_recent = max(
            filter(None, [last_sglang_activity, last_n8n_activity]),
            default=None
        )

        if most_recent:
            idle_seconds = (now - most_recent).total_seconds()
            if idle_seconds > REQUEST_IDLE_TIMEOUT:
                terminate_instance(f"idle_timeout_no_requests ({idle_seconds/60:.1f} min)")
                return
            else:
                app.logger.debug(
                    f"Idle for {idle_seconds/60:.1f} min "
                    f"({REQUEST_IDLE_TIMEOUT/60 - idle_seconds/60:.1f} min remaining)"
                )


def get_status_dict():
    now = datetime.utcnow()

    # Calculate most recent activity from either service
    most_recent = max(
        filter(None, [last_sglang_activity, last_n8n_activity]),
        default=None
    )
    idle_seconds = None
    if most_recent:
        idle_seconds = int((now - most_recent).total_seconds())

    return {
        "instance_id": get_instance_id(),
        "status": "healthy",
        "uptime_minutes": int((now - BOOT_TIME).total_seconds() / 60),
        "idle_minutes": int((now - LAST_ACTIVITY).total_seconds() / 60),
        "shutdown_at": SHUTDOWN_AT.isoformat() + "Z",
        "shutdown_in_minutes": max(0, int((SHUTDOWN_AT - now).total_seconds() / 60)),
        "model_loaded": get_model_loaded(),
        "gpu_utilization": get_gpu_utilization(),
        "boot_time": BOOT_TIME.isoformat() + "Z",
        # Metrics-based activity tracking
        "last_sglang_activity": last_sglang_activity.isoformat() + "Z" if last_sglang_activity else None,
        "last_n8n_activity": last_n8n_activity.isoformat() + "Z" if last_n8n_activity else None,
        "sglang_tokens_total": sglang_tokens_total,
        "n8n_executions_total": n8n_executions_total,
        "sglang_metrics_healthy": sglang_metrics_healthy,
        "n8n_metrics_healthy": n8n_metrics_healthy,
        "idle_seconds": idle_seconds,
        "idle_timeout_minutes": REQUEST_IDLE_TIMEOUT / 60,
    }


# HTML template for dashboard
DASHBOARD_HTML = """
<!DOCTYPE html>
<html>
<head><title>GPU Instance Status</title>
<style>
body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #eee; }
pre { background: #16213e; padding: 15px; border-radius: 8px; }
button { background: #00d4ff; border: none; padding: 10px 20px; cursor: pointer; }
input { padding: 8px; width: 60px; }
</style>
</head>
<body>
<h1>GPU Instance Status</h1>
<pre>{{ status }}</pre>
<form action="/extend" method="post" style="margin-top: 20px;">
    <label>Extend by hours: <input type="number" name="hours" value="2" min="1" max="4"></label>
    <button type="submit">Extend Lease</button>
</form>
<script>setTimeout(() => location.reload(), 30000);</script>
</body>
</html>
"""


@app.route("/")
def index():
    """Simple HTML dashboard."""
    token = request.args.get("token", "")
    if not check_auth() and token != STATUS_TOKEN:
        return "Unauthorized", 401

    import json
    status = json.dumps(get_status_dict(), indent=2)
    return render_template_string(DASHBOARD_HTML, status=status)


@app.route("/health")
def health():
    """Simple health check (no auth required)."""
    return jsonify({"status": "healthy"})


@app.route("/status")
def status():
    if not check_auth():
        return jsonify({"error": "unauthorized"}), 401
    return jsonify(get_status_dict())


@app.route("/shutdown", methods=["POST"])
def shutdown():
    """Administrative shutdown endpoint."""
    if not check_auth():
        return jsonify({"error": "unauthorized"}), 401
    reason = request.json.get("reason", "admin_request") if request.is_json else "admin_request"
    terminate_instance(f"shutdown_requested: {reason}")
    return jsonify({"status": "terminating"})


@app.route("/extend", methods=["POST"])
def extend():
    global SHUTDOWN_AT
    token = request.form.get("token", "")
    if not check_auth() and token != STATUS_TOKEN:
        return jsonify({"error": "unauthorized"}), 401

    hours = int(request.form.get("hours", 2))
    max_allowed = MAX_LEASE_HOURS - ((datetime.utcnow() - BOOT_TIME).total_seconds() / 3600)
    hours = min(hours, int(max_allowed))

    if hours > 0:
        SHUTDOWN_AT = SHUTDOWN_AT + timedelta(hours=hours)

    return jsonify({
        "extended_by_hours": hours,
        "new_shutdown_at": SHUTDOWN_AT.isoformat() + "Z"
    })


@app.route("/activity", methods=["POST"])
def activity():
    global LAST_ACTIVITY
    if not check_auth():
        return jsonify({"error": "unauthorized"}), 401
    LAST_ACTIVITY = datetime.utcnow()
    return jsonify({"last_activity": LAST_ACTIVITY.isoformat() + "Z"})


if __name__ == "__main__":
    checker = threading.Thread(target=idle_checker, daemon=True)
    checker.start()
    app.run(host="0.0.0.0", port={{ status_daemon_port }})
